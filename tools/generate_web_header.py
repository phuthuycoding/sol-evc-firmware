#!/usr/bin/env python3
"""
Generate C++ header file from web assets (gzipped)
Embeds web files into firmware as PROGMEM arrays
"""

Import("env")

import os
import gzip
import binascii
from os.path import join

def generate_web_header(source, target, env):
    """Convert web files to C++ header with PROGMEM"""
    print("=" * 50)
    print("Generating web assets header...")
    print("=" * 50)

    web_src_dir = join(env.subst("$PROJECT_DIR"), "data", "www")
    header_file = join(env.subst("$PROJECT_DIR"), "include", "web_assets.h")

    if not os.path.exists(web_src_dir):
        print(f"No web source directory found at {web_src_dir}")
        return

    # Start header file
    header_content = """/**
 * @file web_assets.h
 * @brief Embedded web assets (auto-generated)
 *
 * DO NOT EDIT MANUALLY - Generated by tools/generate_web_header.py
 */

#ifndef WEB_ASSETS_H
#define WEB_ASSETS_H

#include <Arduino.h>

"""

    files_data = []

    # Process each file
    for filename in os.listdir(web_src_dir):
        filepath = join(web_src_dir, filename)
        if not os.path.isfile(filepath):
            continue

        # Read and gzip file
        with open(filepath, 'rb') as f:
            original_data = f.read()

        gzipped_data = gzip.compress(original_data, compresslevel=9)

        # Convert to C array
        var_name = filename.replace('.', '_').replace('-', '_')
        array_name = f"web_{var_name}_gz"

        print(f"  {filename}: {len(original_data)} → {len(gzipped_data)} bytes (gzip)")

        # Generate C array
        hex_data = ', '.join(f'0x{b:02x}' for b in gzipped_data)

        header_content += f"// {filename} (gzipped)\n"
        header_content += f"const uint8_t {array_name}[] PROGMEM = {{\n"

        # Split into lines of 16 bytes
        hex_bytes = [f'0x{b:02x}' for b in gzipped_data]
        for i in range(0, len(hex_bytes), 16):
            line = ', '.join(hex_bytes[i:i+16])
            header_content += f"    {line},\n"

        header_content += "};\n"
        header_content += f"const size_t {array_name}_len = {len(gzipped_data)};\n\n"

        files_data.append({
            'filename': filename,
            'array': array_name,
            'size': len(gzipped_data)
        })

    # Add lookup struct
    header_content += """
// Web file lookup structure
struct WebFile {
    const char* path;
    const uint8_t* data;
    size_t size;
    const char* contentType;
    bool gzipped;
};

// Web files array
const WebFile WEB_FILES[] PROGMEM = {
"""

    # Add file entries
    for file_info in files_data:
        filename = file_info['filename']
        array = file_info['array']

        # Determine content type
        if filename.endswith('.html'):
            content_type = 'text/html'
        elif filename.endswith('.css'):
            content_type = 'text/css'
        elif filename.endswith('.js'):
            content_type = 'application/javascript'
        elif filename.endswith('.svg'):
            content_type = 'image/svg+xml'
        else:
            content_type = 'application/octet-stream'

        # Map filename to URL path
        path = '/' + filename
        if filename == 'index.html':
            # Also add root path
            header_content += f'    {{"/", {array}, {array}_len, "{content_type}", true}},\n'

        header_content += f'    {{"{path}", {array}, {array}_len, "{content_type}", true}},\n'

    header_content += """};

const size_t WEB_FILES_COUNT = sizeof(WEB_FILES) / sizeof(WebFile);

#endif // WEB_ASSETS_H
"""

    # Write header file
    with open(header_file, 'w') as f:
        f.write(header_content)

    print(f"\n✓ Generated: {header_file}")
    print(f"  Total files: {len(files_data)}")
    total_size = sum(f['size'] for f in files_data)
    print(f"  Total size: {total_size} bytes ({total_size/1024:.1f} KB)")
    print("=" * 50)

# Register callback
env.AddPreAction("$BUILD_DIR/src/main.cpp.o", generate_web_header)
